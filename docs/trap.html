<head>
<title> Open Watcom 2.0 Trap Developers Guide </title>
</head>
<body>
<h1 id="Index_of_Topics"> Index of Topics </h1>
<dl>
<dt>- B -
<dd><a href="#Base_Types">Base Types</a>
<br><a href="#Byte_Order">Byte Order</a>
<dt><br>- C -
<dd><a href="#Core_Requests">Core Requests</a>
<dt><br>- F -
<dd><a href="#File_IDO_requests">File I/O requests</a>
<dt><br>- I -
<dd><a href="#The_Interface_Routines">The Interface Routines</a>
<br><a href="#Introduction">Introduction</a>
<dt><br>- O -
<dd><a href="#Overlay_requests">Overlay requests</a>
<dt><br>- P -
<dd><a href="#Pointer_Sizes">Pointer Sizes</a>
<dt><br>- R -
<dd><a href="#REQ_ADDR_INFO_L8R">REQ_ADDR_INFO (8)</a>
<br><a href="#REQ_CHECKSUM_MEM_L9R">REQ_CHECKSUM_MEM (9)</a>
<br><a href="#REQ_CLEAR_BREAK_L25R">REQ_CLEAR_BREAK (25)</a>
<br><a href="#REQ_CLEAR_WATCH_L23R">REQ_CLEAR_WATCH (23)</a>
<br><a href="#REQ_CONNECT_L0R">REQ_CONNECT (0)</a>
<br><a href="#REQ_DISCONNECT_L1R">REQ_DISCONNECT (1)</a>
<br><a href="#REQ_FILE_CLOSE_L6R">REQ_FILE_CLOSE (6)</a>
<br><a href="#REQ_FILE_ERASE_L7R">REQ_FILE_ERASE (7)</a>
<br><a href="#REQ_FILE_GET_CONFIG_L0R">REQ_FILE_GET_CONFIG (0)</a>
<br><a href="#REQ_FILE_OPEN_L1R">REQ_FILE_OPEN (1)</a>
<br><a href="#REQ_FILE_READ_L3R">REQ_FILE_READ (3)</a>
<br><a href="#REQ_FILE_RUN_CMD_L9R">REQ_FILE_RUN_CMD (9)</a>
<br><a href="#REQ_FILE_SEEK_L2R">REQ_FILE_SEEK (2)</a>
<br><a href="#REQ_FILE_STRING_TO_FULLPATH_L8R">REQ_FILE_STRING_TO_FULLPATH (8)</a>
<br><a href="#REQ_FILE_WRITE_L4R">REQ_FILE_WRITE (4)</a>
<br><a href="#REQ_FILE_WRITE_CONSOLE_L5R">REQ_FILE_WRITE_CONSOLE (5)</a>
<br><a href="#REQ_GET_ERR_TEXT_L31R">REQ_GET_ERR_TEXT (31)</a>
<br><a href="#REQ_GET_LIB_NAME_L30R">REQ_GET_LIB_NAME (30)</a>
<br><a href="#REQ_GET_MESSAGE_TEXT_L32R">REQ_GET_MESSAGE_TEXT (32)</a>
<br><a href="#REQ_GET_NEXT_ALIAS_L26R">REQ_GET_NEXT_ALIAS (26)</a>
<br><a href="#REQ_GET_SUPPLEMENTARY_SERVICE_L4R">REQ_GET_SUPPLEMENTARY_SERVICE (4)</a>
<br><a href="#REQ_GET_SYS_CONFIG_L6R">REQ_GET_SYS_CONFIG (6)</a>
<br><a href="#REQ_MACHINE_DATA_L38R">REQ_MACHINE_DATA (38)</a>
<br><a href="#REQ_MAP_ADDR_L7R">REQ_MAP_ADDR (7)</a>
<br><a href="#REQ_OVL_GET_DATA_L1R">REQ_OVL_GET_DATA (1)</a>
<br><a href="#REQ_OVL_GET_REMAP_ENTRY_L6R">REQ_OVL_GET_REMAP_ENTRY (6)</a>
<br><a href="#REQ_OVL_READ_STATE_L2R">REQ_OVL_READ_STATE (2)</a>
<br><a href="#REQ_OVL_STATE_SIZE_L0R">REQ_OVL_STATE_SIZE (0)</a>
<br><a href="#REQ_OVL_TRANS_RET_ADDR_L5R">REQ_OVL_TRANS_RET_ADDR (5)</a>
<br><a href="#REQ_OVL_TRANS_VECT_ADDR_L4R">REQ_OVL_TRANS_VECT_ADDR (4)</a>
<br><a href="#REQ_OVL_WRITE_STATE_L3R">REQ_OVL_WRITE_STATE (3)</a>
<br><a href="#REQ_PERFORM_SUPPLEMENTARY_SERVICE_L5R">REQ_PERFORM_SUPPLEMENTARY_SERVICE (5)</a>
<br><a href="#REQ_PROG_GO_L18RDREQ_PROG_STEP_L19R">REQ_PROG_GO (18)/REQ_PROG_STEP (19)</a>
<br><a href="#REQ_PROG_KILL_L21R">REQ_PROG_KILL (21)</a>
<br><a href="#REQ_PROG_LOAD_L20R">REQ_PROG_LOAD (20)</a>
<br><a href="#REQ_READ_CPU_L14R">REQ_READ_CPU (14)</a>
<br><a href="#REQ_READ_FPU_L15R">REQ_READ_FPU (15)</a>
<br><a href="#REQ_READ_IO_L12R">REQ_READ_IO (12)</a>
<br><a href="#REQ_READ_MEM_L10R">REQ_READ_MEM (10)</a>
<br><a href="#REQ_READ_REGS_L36R">REQ_READ_REGS (36)</a>
<br><a href="#REQ_READ_USER_KEYBOARD_L29R">REQ_READ_USER_KEYBOARD (29)</a>
<br><a href="#REQ_REDIRECT_STDIN_L33RDREQ_REDIRECT_STDOUT_L34R">REQ_REDIRECT_STDIN (33)/REQ_REDIRECT_STDOUT (34)</a>
<br><a href="#REQ_RESUME_L3R">REQ_RESUME (3)</a>
<br><a href="#REQ_RFX_FINDCLOSE_L15R">REQ_RFX_FINDCLOSE (15)</a>
<br><a href="#REQ_RFX_FINDFIRST_L13R">REQ_RFX_FINDFIRST (13)</a>
<br><a href="#REQ_RFX_FINDNEXT_L14R">REQ_RFX_FINDNEXT (14)</a>
<br><a href="#REQ_RFX_GETCWD_L6R">REQ_RFX_GETCWD (6)</a>
<br><a href="#REQ_RFX_GETDATETIME_L8R">REQ_RFX_GETDATETIME (8)</a>
<br><a href="#REQ_RFX_GETDRIVE_L4R">REQ_RFX_GETDRIVE (4)</a>
<br><a href="#REQ_RFX_GETFILEATTR_L11R">REQ_RFX_GETFILEATTR (11)</a>
<br><a href="#REQ_RFX_GETFREESPACE_L9R">REQ_RFX_GETFREESPACE (9)</a>
<br><a href="#REQ_RFX_MKDIR_L1R">REQ_RFX_MKDIR (1)</a>
<br><a href="#REQ_RFX_NAMETOCANNONICAL_L12R">REQ_RFX_NAMETOCANNONICAL (12)</a>
<br><a href="#REQ_RFX_RENAME_L0R">REQ_RFX_RENAME (0)</a>
<br><a href="#REQ_RFX_RMDIR_L2R">REQ_RFX_RMDIR (2)</a>
<br><a href="#REQ_RFX_SETCWD_L5R">REQ_RFX_SETCWD (5)</a>
<br><a href="#REQ_RFX_SETDATETIME_L7R">REQ_RFX_SETDATETIME (7)</a>
<br><a href="#REQ_RFX_SETDRIVE_L3R">REQ_RFX_SETDRIVE (3)</a>
<br><a href="#REQ_RFX_SETFILEATTR_L10R">REQ_RFX_SETFILEATTR (10)</a>
<br><a href="#REQ_SET_BREAK_L24R">REQ_SET_BREAK (24)</a>
<br><a href="#REQ_SET_DEBUG_SCREEN_L28R">REQ_SET_DEBUG_SCREEN (28)</a>
<br><a href="#REQ_SET_USER_SCREEN_L27R">REQ_SET_USER_SCREEN (27)</a>
<br><a href="#REQ_SET_WATCH_L22R">REQ_SET_WATCH (22)</a>
<br><a href="#REQ_SPLIT_CMD_L35R">REQ_SPLIT_CMD (35)</a>
<br><a href="#REQ_SUSPEND_L2R">REQ_SUSPEND (2)</a>
<br><a href="#REQ_THREAD_FREEZE_L2R">REQ_THREAD_FREEZE (2)</a>
<br><a href="#REQ_THREAD_GET_EXTRA_L4R">REQ_THREAD_GET_EXTRA (4)</a>
<br><a href="#REQ_THREAD_GET_NEXT_L0R">REQ_THREAD_GET_NEXT (0)</a>
<br><a href="#REQ_THREAD_SET_L1R">REQ_THREAD_SET (1)</a>
<br><a href="#REQ_THREAD_THAW_L3R">REQ_THREAD_THAW (3)</a>
<br><a href="#REQ_WRITE_CPU_L16RDREQ_WRITE_FPU_L17R">REQ_WRITE_CPU (16)/REQ_WRITE_FPU (17)</a>
<br><a href="#REQ_WRITE_IO_L13R">REQ_WRITE_IO (13)</a>
<br><a href="#REQ_WRITE_MEM_L11R">REQ_WRITE_MEM (11)</a>
<br><a href="#REQ_WRITE_REGS_L37R">REQ_WRITE_REGS (37)</a>
<br><a href="#Request_Example">Request Example</a>
<br><a href="#The_Request_Interface">The Request Interface</a>
<br><a href="#Request_Structure_">Request Structure.</a>
<br><a href="#The_Requests">The Requests</a>
<br><a href="#RFX_requests">RFX requests</a>
<dt><br>- S -
<dd><a href="#Some_Definitions">Some Definitions</a>
<br><a href="#System_Dependent_Aspects">System Dependent Aspects</a>
<dt><br>- T -
<dd><a href="#Thread_requests">Thread requests</a>
<br><a href="#Trap_Files_Under_DOS">Trap Files Under DOS</a>
<br><a href="#Trap_Files_Under_Netware_386">Trap Files Under Netware 386</a>
<br><a href="#Trap_Files_Under_OSD2">Trap Files Under OS/2</a>
<br><a href="#Trap_Files_Under_QNX">Trap Files Under QNX</a>
<br><a href="#Trap_Files_Under_Windows_NT_">Trap Files Under Windows NT.</a>
<br><a href="#Trap_Files_Under_Windows_">Trap Files Under Windows.</a>
<br><a href="#TrapFini">TrapFini</a>
<br><a href="#TrapInit">TrapInit</a>
<br><a href="#TrapRequest">TrapRequest</a>
</dl>
<h1 id="Introduction"> Introduction </h1>
<br>The Open Watcom debugger consists of a number of separate pieces of code.&nbsp; The main executable, WD.EXE (wd on UNIX
systems), provides a debugging `engine' and user interface.&nbsp; When the engine wishes to perform an operation upon the
program being debugged such as reading memory or setting a breakpoint, it creates a request structure and sends it to the
`trap file' (so called because under DOS, it contains the first level trap handlers).&nbsp; The trap file examines the request
structure, performs the indicated action and returns a result structure to the debugger.&nbsp; The debugger and trap files
also use Machine Architecture Description (MAD) files which abstract the CPU architecture.&nbsp; This design has the following
benefits:
<ol>
<li>OS debugging interfaces tend to be wildly varying in how they are accessed.&nbsp; By moving all the OS specific interface
code into the trap file and having a defined interface to access it, porting the debugger becomes much easier.
<li>By abstracting the machine architecture specifics through MAD files, it becomes possible to use one debugger for several
target CPU architectures (such as x86 and Alpha AXP).&nbsp; Unlike most other debuggers, the Open Watcom debugger is not tied
to a single host/target combination and if appropriate trap and MAD files are available, the debugger running on any host
can remotely debug any target.
<li>The trap file does not have to actually perform the operation.&nbsp; Instead it could send the request out to a remote
server by a communication link such as a serial line or LAN.&nbsp; The remote server can retrieve the request, perform the
operation on the remote machine and send the results back via the link.&nbsp; This enables the debugger to debug applications
in cases where there are memory constraints or other considerations which prevent the debugger proper from running on the
remote system (such as Novell Netware 386).
</ol>
<br>This document describes the interface initially used by version 4.0 of the WATCOM debugger (shipped with the 10.0 C/C++
and FORTRAN releases).&nbsp; It has been revised to describe changes incorporated in Watcom 11.0 release, as well as subsequent
Open Watcom releases.&nbsp; It is expected to be modified in future releases.&nbsp; Where possible, notification of expected
changes are given in the document, but all aspects are subject to revision.
<h2 id="Some_Definitions"> Some Definitions </h2>
<br>Next follow some general trap definitions.
<h3 id="Byte_Order"> Byte Order </h3>
<br>The trap file interface is defined to use little endian byte order.&nbsp; That is, the least significant byte is stored
at the lowest address.&nbsp; Little endian byte order was chosen for compatibility with existing trap files and tools.&nbsp;
Fixed byte order also eases network communication between debuggers and trap files running on machines with different byte
order.
<h3 id="Pointer_Sizes"> Pointer Sizes </h3>
<br>In a 16-bit hosted environment such as DOS, all pointers used by the trap file are &quot;far&quot; 16:16 pointers.&nbsp;
In a 32-bit environment such as Windows NT the pointers are &quot;near&quot; 0:32 pointers.
<h3 id="Base_Types"> Base Types </h3>
<br>A number of basic types are used in the interface.&nbsp; They are defined as follows:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>unsigned_8
<dd>1 byte unsigned quantity
<dt><br>unsigned_16
<dd>2 byte unsigned quantity
<dt><br>unsigned_32
<dd>4 byte unsigned quantity
<dt><br>access_req
<dd>The first field of every request is of this type.&nbsp; It is a 1 byte field which identifies the request to be performed.
<dt><br>addr48_ptr
<dd>This type encapsulates the concept of a 16:32 pointer.&nbsp; All addresses in the debuggee memory are described with these.
&nbsp;The debugger always acts as if the debuggee were in a 32-bit large model environment since the 32-bit flat model and
all 16-bit memory models are subsets.&nbsp; The structure is defined as follows:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp; offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; segment;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } addr48_ptr;</tt>
<br><br>The<tt> segment</tt> field contains the segment of the address and the<tt> offset</tt> field stores the offset of
the address.
<dt><br>bytes
<dd>The type<tt> bytes</tt> is an array of unsigned_8.&nbsp; The length is provided by other means.&nbsp; Typically a field of
type<tt> bytes</tt> is the last one in a request and the length is calculated from the total length of the request.
<dt><br>string
<dd>The type<tt> string</tt> is actually an array of characters.&nbsp; The array is terminated by a null ('\0') character.&nbsp;
The length is provided by other means.&nbsp; Typically a field of type<tt> string</tt> is the last one in a request and the
length is calculated from the total length of the request.
<dt><br>trap_error
<dd>Some trap file requests return debuggee operating system error codes, notably the requests to perform file I/O on the remote
system.&nbsp; These error codes are returned as an unsigned_32.&nbsp; The debugger considers the value zero to indicate no
error.
<dt><br>trap_phandle
<dd>This is an<tt> unsigned_32</tt> which holds process (task) handle.&nbsp; A task handle is used to uniquely identify a debuggee
process.
<dt><br>trap_mhandle
<dd>This is an<tt> unsigned_32</tt> which holds a module handle.&nbsp; Typically the main executable will be one module, and on
systems which support DLLs or shared libraries, each library will be identified by a unique module handle.
</dl>
<h1 id="The_Request_Interface"> The Request Interface </h1>
<br>Next follow detailed description of interface elements.
<h2 id="Request_Structure_"> Request Structure. </h2>
<br>Each request is a composed of two sequences of bytes provided by the debugger called messages.&nbsp; The first set contains
the actual request code and whatever parameters that are required by the request.&nbsp; The second sequence is where the result
of the operation is to be stored by the trap file.
<br><br>The two sequences need not be contiguous.&nbsp; The sequences are described to the trap file through two arrays of
message entry structures.&nbsp; This allows the debugger to avoid unnecessary packing and unpacking of messages, since<tt>
mx_entry</tt>'s can be set to point directly at parameter/result buffers.
<br><br>Multiple requests are<b> not</b> allowed in a single message.&nbsp; The<tt> mx_entry</tt>'s are only used to provide
scatter/gather capabilities for one request at a time.
<br><br>The message entry structure is as follows (defined in<tt> trptypes.h</tt>):
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*ptr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } mx_entry;</tt>
<br><br>The<tt> ptr</tt> is pointing to a block of data for that message entry.&nbsp; The<tt> len</tt> field gives the length
of that block.&nbsp; One array of<tt> mx_entry</tt>'s describes the request message.&nbsp; The second array describes the
return message.
<br><br>It is not legal to split a message into arbitrary pieces with mx_entries.&nbsp; Each request documents where an<tt>
mx_entry</tt> is allowed to start with a line of dashes.
<h2 id="The_Interface_Routines"> The Interface Routines </h2>
<br>The trap file interface must provide three routines:<tt>&nbsp; TrapInit</tt>,<tt> TrapRequest</tt>, and<tt> TrapFini</tt>.
&nbsp;How the debugger determines the address of these routines after loading a trap file, as well as the calling convention
used, is system dependent and described later.&nbsp; These functions are prototyped in<tt> trpimp.h</tt>.
<h3 id="TrapInit"> TrapInit </h3>
<br>This function initializes the environment for proper operation of<tt> TrapRequest</tt>.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_version TRAPENTRY TrapInit(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *parm,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *error,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8 remote</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; );</tt>
<br><br>The<tt> parm</tt> is a string that the user passes to the trap file.&nbsp; Its interpretation is completely up to
the trap file.&nbsp; In the case of the Open Watcom debugger, all the characters following the semicolon in the<tt> /TRAP</tt>
option are passed as the<tt> parm</tt>.&nbsp; For example:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; wd /trap=nov;testing program</tt>
<br><br>The<tt> parm</tt> would be &quot;testing&quot;.&nbsp; Any error message will be returned in<tt> error</tt>.&nbsp;
The<tt> remote</tt> field is a zero if the Open Watcom debugger is loading the trap file and a one if a remote server is loading
it.&nbsp; This function returns a structure<tt> trap_version</tt> of the following form (defined in<tt> trptypes.h</tt>):
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; major;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; minor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; remote;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } trap_version;</tt>
<br><br>The<tt> major</tt> field contains the major version number of the trap file while the<tt> minor</tt> field tells the
minor version number of the trap file.<tt>&nbsp; Major</tt> is changed whenever there is a modification made to the trap file
that is not upwardly compatable with previous versions.<tt>&nbsp; Minor</tt> increments by one whenever a change is made to
the trap file that is upwardly compatible with previous versions.&nbsp; The current major verion is 17, the current minor
version is 1.&nbsp; The<tt> remote</tt> field informs the debugger whether the trap file communicates with a remote machine.
<br><br><tt>TrapInit</tt> must be called before using<tt> TrapRequest</tt> to send a request.&nbsp; Failure to do so may result
in unpredictable operation of<tt> TrapRequest</tt>.
<h3 id="TrapRequest"> TrapRequest </h3>
<br>All requests between the server and the remote trap file are handled by TrapRequest.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned TRAPENTRY TrapRequest(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned num_in_mx,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mx_entry *mx_in,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned num_out_mx,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mx_entry *mx_out</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; );</tt>
<br><br>The<tt> mx_in</tt> points to an array of request mx_entry's.&nbsp; The<tt> num_in_mx</tt> field contains the number
of elements of the array.&nbsp; Similarly, the<tt> mx_out</tt> will point to an array of return mx_entry's.&nbsp; The number
of elements will be given by the<tt> num_out_mx</tt> field.&nbsp; The total number of bytes actually filled in to the return
message by the trap file is returned by the function (this may be less than the total number of bytes described by the<tt>
mx_out</tt> array).
<br><br>Since every request must start with an<tt> access_req</tt> field, the minimum size of a request message is one byte.
<br><br>Some requests do not require a return message.&nbsp; In this case, the program invoking TrapRequest<b> must</b> pass
zero for<tt> num_out_mx</tt> and NULL for<tt> mx_out</tt>.
<h4 id="Request_Example"> Request Example </h4>
<br>The request REQ_READ_MEM needs the memory address and length of memory to read as input and will return the memory block
in the output message.&nbsp; To read 30 bytes of memory from address 0x0010:0x8000 into a buffer, we can write:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mx_entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mx_entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; buffer&#91;30&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct in_msg_def {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } in_msg = { REQ_READ_MEM, { 0x8000, 0x0010 }, sizeof( buffer ) };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 mem_blk_len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; in&#91;0&#93;.ptr = &amp;in_msg;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; in&#91;0&#93;.len = sizeof( in_msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; out&#91;0&#93;.ptr = &amp;buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; out&#91;0&#93;.len = sizeof( buffer );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mem_blk_len = TrapRequest( 1, in, 1, out );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( mem_blk_length != sizeof( buffer ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in reading memory\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br>The program will print &quot;OK&quot; if it has transferred 30 bytes of data from the debuggee's address space to
the<tt> buffer</tt> variable.&nbsp; If less than 30 bytes is transfered, an error message is printed out.
<h3 id="TrapFini"> TrapFini </h3>
<br>The function terminates the link between the debugger and the trap file.&nbsp; It should be called after finishing all
access requests.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; void TRAPENTRY TrapFini( void );</tt>
<br><br>After calling<tt> TrapFini</tt>, it is illegal to call<tt> TrapRequest</tt> without calling<tt> TrapInit</tt> again.
<h1 id="The_Requests"> The Requests </h1>
<br>This section descibes the individual requests, their parameters, and their return values.&nbsp; A line of dashes indicates
where an<tt> mx_entry</tt> is allowed (but not required) to start.&nbsp; The debugger allows (via REQ_GET_SUPPLEMENTARY_SERVICE/REQ_PERFORM_SUPPLEMENTARY_SERVICE)
optional components to be implemented only on specific systems.
<br>The numeric value of the request which is placed in the<tt> req</tt> field follows the symbolic name in parentheses.
<h2 id="Core_Requests"> Core Requests </h2>
<br>These requests need to be implemented in all versions of the trap file, although some of them may only be stub implementations
in some environments.&nbsp; Note that structures suitable for individual requests are declared in<tt> trpcore.h</tt>.
<h3 id="REQ_CONNECT_L0R"> REQ_CONNECT (0) </h3>
<br>Request to connect to the remote machine.&nbsp; This must be the first request made.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; major;&nbsp;&nbsp; &lt;-+- struct trap_version</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remote;&nbsp; &lt;-+</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> trap_version</tt> structure tells the version of the program
making the request.&nbsp; The<tt> major</tt> field contains the major version number of the trap file while the<tt> minor</tt>
field tells the minor version number of the trap file.&nbsp; The<tt> major</tt> is changed whenever there is a modification
made to the trap file that is not upwardly compatable with previous versions.&nbsp; The<tt> minor</tt> increments by one whenever
a change is made to the trap file that is upwardly compatable with previous versions.&nbsp; The current major version is 17,
the current minor version is 1.&nbsp; The<tt> remote</tt> field informs the trap file whether a remote server is between the
Open Watcom debugger and the trap file.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 max_msg_size</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err_msg</tt>
<br><br>If error has occurred, the<tt> err_msg</tt> field will returns the error message string.&nbsp; If there is no error,<tt>
error_msg</tt> returns a null character and the field<tt> max_msg_size</tt> will contain the allowed maximum size of a message
in bytes.&nbsp; Any message (typically reading/writing memory or files) which would require more than the maximum number of
bytes to transmit or receive must be broken up into multiple requests.&nbsp; The minimum acceptable value for this field is
256.
<h3 id="REQ_DISCONNECT_L1R"> REQ_DISCONNECT (1) </h3>
<br>Request to terminate the link between the local and remote machine.&nbsp; After this request, a REQ_CONNECT must be the
next one made.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_SUSPEND_L2R"> REQ_SUSPEND (2) </h3>
<br>Request to suspend the link between the server and the remote trap file.&nbsp; The debugger issues this message just before
it spawns a sub-shell (the &quot;system&quot; command).&nbsp; This allows a remote server to enter a state where it allows
other trap files to connect to it (normally, once a remote server has connected to a trap file, the remote link will fail
any other attempts to connect to it).&nbsp; This allows the user for instance to start up an RFX process and transfer any
missing files to the remote machine before continuing the debugging process.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_RESUME_L3R"> REQ_RESUME (3) </h3>
<br>Request to resume the link between the server and the remote trap file.&nbsp; The debugger issues this request when the
spawned sub-shell exits.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_GET_SUPPLEMENTARY_SERVICE_L4R"> REQ_GET_SUPPLEMENTARY_SERVICE (4) </h3>
<br>Request to obtain a supplementary service id.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service_name</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> service_name</tt> field contains a string identifying the
supplementary service.&nbsp; This string is case insensitive.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_shandle&nbsp;&nbsp;&nbsp; id;</tt>
<br><br>The<tt> err</tt> field is non-zero if something went wrong in obtaining or initializing the service.<tt>&nbsp; Id</tt>
is the identifier for a particular supplementary service.&nbsp; It need not be the same from one invocation of the trap file
to another.&nbsp; If both it and the<tt> err</tt> field are zero, it means that the service is not available from this trap
file.
<br><br><b>NOTE:</b>&nbsp; integrated with the debugger.&nbsp; There would be two components, one to be added to the debugger
and one to be added to the trap file.&nbsp; The two pieces could communicate with each other via the supplementary services
mechanism.
<h3 id="REQ_PERFORM_SUPPLEMENTARY_SERVICE_L5R"> REQ_PERFORM_SUPPLEMENTARY_SERVICE (5) </h3>
<br>Request to perform a supplementary service.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 service_id</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> service_id</tt> field indicates which service is being
requested.&nbsp; The remainder of the request is specified by the individual supplementary service provider.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The return message is specified by the individual supplementary service provider.
<h3 id="REQ_GET_SYS_CONFIG_L6R"> REQ_GET_SYS_CONFIG (6) </h3>
<br>Request to get system information from the remote machine.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; cpu;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; fpu;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; osmajor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; osminor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; os;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; huge_shift;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mad_handle&nbsp; mad;</tt>
<br><br>The<tt> mad</tt> field specifies the MAD (Machine Architecture Description) in use and determines how the other fields
will be interpreted.&nbsp; Currently the following MADs are used:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_X86 - Intel IA-32 compatible</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_AXP - Alpha AXP</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAD_PPC - PowerPC</tt>
<br><br>The<tt> cpu</tt> fields returns the type of the remote CPU.&nbsp; The size of that field is unsigned_8.&nbsp; Possible
CPU types for MAD_X86 are:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bits 0-3</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_86&nbsp; = 0&nbsp;&nbsp; - 8086</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_186 = 1&nbsp;&nbsp; - 80186</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_286 = 2&nbsp;&nbsp; - 80286</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_386 = 3&nbsp;&nbsp; - 80386</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_486 = 4&nbsp;&nbsp; - 80486</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_586 = 5&nbsp;&nbsp; - Pentium</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_686 = 6&nbsp;&nbsp; - Pentium Pro/II/III</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86_P4&nbsp; = 15&nbsp; - Pentium 4</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bit&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - MM registers</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bit&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - XMM registers</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bits 6,7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - unused</tt>
<br><br>The<tt> fpu</tt> fields tells the type of FPU.&nbsp; The size of the field is unsigned_8.&nbsp; FPU types for MAD_X86
include:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_EMU = -1&nbsp;&nbsp;&nbsp;&nbsp; - Software emulated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_NO&nbsp; =&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; - No FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_87&nbsp; =&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; - 8087</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_287 =&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; - 80287</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_387 =&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; - 80387</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_487 =&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; - 486 integrated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_587 =&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; - Pentium integrated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_587 =&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; - Pentium Pro/II/III integrated FPU</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; X86_P47 =&nbsp; 15&nbsp;&nbsp;&nbsp; - Pentium 4 integrated FPU</tt>
<br><br>The<tt> osmajor</tt> and<tt> osminor</tt> contains the major and minor version number for the operating system of
the remote machine.&nbsp; The type of operating system can be found in<tt> os</tt> field.&nbsp; The size of this field is
unsigned_8.&nbsp; The OS can be:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_IDUNNO&nbsp;&nbsp;&nbsp; =&nbsp; 0&nbsp;&nbsp; - Unknown operating system</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_DOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 1&nbsp;&nbsp; - DOS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_OS2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 2&nbsp;&nbsp; - OS/2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_PHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 3&nbsp;&nbsp; - Phar Lap 386 DOS Extender</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_ECLIPSE&nbsp;&nbsp; =&nbsp; 4&nbsp;&nbsp; - Eclipse 386 DOS Extender (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_NW386&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 5&nbsp;&nbsp; - NetWare 386</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_QNX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp; 6&nbsp;&nbsp; - QNX 4.x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_RATIONAL&nbsp; =&nbsp; 7&nbsp;&nbsp; - DOS/4G or compatible</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_WINDOWS&nbsp;&nbsp; =&nbsp; 8&nbsp;&nbsp; - Windows 3.x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_PENPOINT&nbsp; =&nbsp; 9&nbsp;&nbsp; - PenPoint (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_NT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 10&nbsp;&nbsp; - Win32</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_AUTOCAD&nbsp;&nbsp; = 11&nbsp;&nbsp; - ADS/ADI development (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_NEUTRINO&nbsp; = 12&nbsp;&nbsp; - QNX 6.x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; OS_LINUX&nbsp;&nbsp;&nbsp;&nbsp; = 13&nbsp;&nbsp; - Linux</tt>
<br><br>The<tt> huge_shift</tt> field is used to determine the shift needed for huge arithmetic in that system.&nbsp; It stores
the number of left shifts required in order to calculate the next segment correctly.&nbsp; It is 12 for real mode programs.
&nbsp;The value in a protect mode environment must be obtained from the OS of the debuggee machine.&nbsp; This field is only
relevant for 16-bit segmented architectures.
<h3 id="REQ_MAP_ADDR_L7R"> REQ_MAP_ADDR (7) </h3>
<br>Request to map the input address to the actual address of the remote machine.&nbsp; The addresses in the symbolic information
provided by the linker do not reflect any relocation performed on the executable by the system loader.&nbsp; This request
obtains that relocation information so that the debugger can update its addresses.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; handle;</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> in_addr</tt> tells the address to map.&nbsp; The<tt> handle</tt>
field identifies the module which the address is from.&nbsp; The value from this field is obtained by REQ_PROG_LOAD or REQ_GET_LIB_NAME.
&nbsp;There are two magical values for the<tt> in_addr.segment</tt> field.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAP_FLAT_CODE_SELECTOR&nbsp; = -1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MAP_FLAT_DATA_SELECTOR&nbsp; = -2</tt>
<br><br>When the<tt> in_addr.segment</tt> equals one of these values, the debugger does not have a map segment value and is
requesting that the trap file performs the mapping as if the given offset was in the flat address space.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lo_bound;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hi_bound;</tt>
<br><br>The mapped address is returned in<tt> out_addr</tt>.&nbsp; Note that in addition to the segment portion being modified,
the offset of the portion of the address may be adjusted as well if the loader performs offset relocations (like OS/2 2.x
or Windows NT).&nbsp; The<tt> lo_bound</tt> and<tt> hi_bound</tt> fields identify the lowest and highest input offsets for
which this mapping is valid.&nbsp; If the debugger needs to map another address whose input segment value is the same as a
previous request, and the input offset falls within the valid range identified by the return of that previous request, it
can perform the mapping itself and not bother sending the request to the trap file.
<h3 id="REQ_ADDR_INFO_L8R"> REQ_ADDR_INFO (8) </h3>
<br>This request is x86 specific and obsolete; REQ_MACHINE_DATA should be used instead.&nbsp; It needs to be provided only
for backwards compatibility.
<br><br>Request to check if a given address is using 32-bit addressing (the 386 compatible CPU's current selector's B-bit
is on) by default.&nbsp; The debugger requires this information to properly disassemble instructions.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_addr</tt>
<br><br>The<tt> req</tt> field contains the request and the<tt> in_addr</tt> tells the input address.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_32</tt>
<br><br>The field returns one if the address is a USE32 segment, zero otherwise.
<h3 id="REQ_CHECKSUM_MEM_L9R"> REQ_CHECKSUM_MEM (9) </h3>
<br>Request to calculate the checksum for a block of memory in the debuggee's address space.&nbsp; This is used by the debugger
to determine if the contents of the memory block have changed since the last time it was read.&nbsp; Since only a four byte
checksum has to be transmitted back, it is more efficient than actually reading the memory again.&nbsp; The debugger does
not care how the checksum is calculated.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><br>The<tt> req</tt> field stores the request.&nbsp; The<tt> in_addr</tt> contains the starting address and the<tt> len</tt>
field tells how large the block of memory is.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
<br><br>The checksum will be returned in<tt> result</tt>.
<h3 id="REQ_READ_MEM_L10R"> REQ_READ_MEM (10) </h3>
<br>Request to read a block of memory.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><br>The<tt> mem_addr</tt> contains the address of the memory block to read from the remote machine.&nbsp; The length of
the block is determined by<tt> len</tt>.&nbsp; The memory data will be copied to output message.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field stores the memory block read in.&nbsp; The length of this memory block is given by the return
value from TrapRequest.&nbsp; If error has occurred in reading memory, the length of the data returns will not be equal to
the number of bytes requested.
<h3 id="REQ_WRITE_MEM_L11R"> REQ_WRITE_MEM (11) </h3>
<br>Request to write a block of memory.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field stores the memory data to be transferred.&nbsp; The data will be stored in the debuggee's
address space starting at the address in the<tt> mem_addr</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 len</tt>
<br><br>The<tt> len</tt> field tells the length of memory block actually written to the debuggee machine.&nbsp; If error has
occurred in writing the memory, the length returned will not be equal to the number of bytes requested.
<h3 id="REQ_READ_IO_L12R"> REQ_READ_IO (12) </h3>
<br>Request to read data from I/O address space of the debuggee.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; IO_offset</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>The<tt> IO_offset</tt> contains the I/O address of the debuggee machine.&nbsp; The length of the block is determined
by<tt> len</tt>.&nbsp; It must be 1, 2 or 4 bytes.&nbsp; The data will be copied from<tt> IO_offset</tt> to the return message.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field stores the memory block read in.&nbsp; The length of this memory block is given by the return
value from TrapRequest.&nbsp; If an error has occurred in reading, the length returned will not be equal to the number of
bytes requested.
<h3 id="REQ_WRITE_IO_L13R"> REQ_WRITE_IO (13) </h3>
<br>Request to write data to the I/O address space of the debuggee.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; IO_offset</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> IO_offset</tt> contains the I/O address of the debuggee machine.&nbsp; The data stored in<tt> data</tt> field
will be copied to<tt> IO_offset</tt> on the debuggee machine.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp; len</tt>
<br><br>The<tt> len</tt> field tells the number of bytes actually written out.&nbsp; If an error has occurred in writing,
the length returned will not be equal to the number of bytes requested.
<h3 id="REQ_READ_CPU_L14R"> REQ_READ_CPU (14) </h3>
<br>This request is x86 specific and obsolete; REQ_READ_REGS should be used instead.&nbsp; It needs to be provided only for
backwards compatibility.
<br><br>Request to read the CPU registers.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field contains the register information requested.&nbsp; It contains the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct cpu_regs {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 EAX;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 EBX;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 ECX;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 EDX;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 ESI;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 EDI;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 EBP;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 ESP;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 EIP;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 EFL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 CR0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 CR2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32 CR3;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 DS;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 ES;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 SS;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 CS;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 FS;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 GS;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<h3 id="REQ_READ_FPU_L15R"> REQ_READ_FPU (15) </h3>
<br>This request is x86 specific and obsolete; REQ_READ_REGS should be used instead.&nbsp; It needs to be provided only for
backwards compatibility.
<br><br>Request to read the FPU registers.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field contains the register information requested.&nbsp; Its format is the same as the result of
a &quot;fsave&quot; instruction in a 32-bit segment (the instruction pointer and operand pointer fields take up 8 bytes each).
&nbsp;Implementations of trap files in 16-bit environments should expand the instruction pointer and operand pointer fields
from 4 bytes to 8 (shuffling the data register fields down in memory) before returning the result to the debugger.
<h3 id="REQ_WRITE_CPU_L16RDREQ_WRITE_FPU_L17R"> REQ_WRITE_CPU (16)/REQ_WRITE_FPU (17) </h3>
<br>These requests are x86 specific and obsolete; REQ_WRITE_REGS should be used instead.&nbsp; They needs to be provided only
for backwards compatibility.
<br><br>Requests to write to the CPU or FPU state.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
data</tt>
<br><br>Information in<tt> data</tt> field will be transfered to the debuggee's registers.&nbsp; The formats of data can be
found in REQ_READ_CPU/REQ_READ_FPU
<br><br><b>NOTE:</b>&nbsp; For the REQ_WRITE_FPU case, the data will be in a 32-bit &quot;fsave&quot; instruction format,
so 16-bit environments will have to squish the instruction and operand pointer fields back to their 4 byte forms.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_PROG_GO_L18RDREQ_PROG_STEP_L19R"> REQ_PROG_GO (18)/REQ_PROG_STEP (19) </h3>
<br>Requests to execute the debuggee.&nbsp; REQ_PROG_GO causes the debuggee to resume execution, while REQ_PROG_STEP requests
only a single machine instruction to be executed before returning.&nbsp; In either case, this request will return when a breakpoint,
watchpoint, machine exception or other significant event has been encountered.&nbsp; While executing, a trap file is allowed
to return spurious COND_WATCH indications.&nbsp; The debugger always checks its own watchpoint table for changes before reporting
to the user.&nbsp; This means that a legal implementation of a trap file (but<b> very</b> inefficient) can just single step
the program and return COND_WATCH for every instruction when there are active watchpoints present.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The request is in<tt> req</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack_pointer</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program_counter</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; conditions</tt>
<br><br>The<tt> stack_pointer</tt> and<tt> program_counter</tt> fields store the latest values of SS:ESP and CS:EIP (or their
non-x86 equivalents) respectively.&nbsp; The<tt> conditions</tt> informs the debugger what conditions have changed since execution
began.&nbsp; It contains the following flags:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp; : COND_CONFIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Configurations change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp; : COND_SECTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program
overlays change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp; : COND_LIBRARIES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Libraries
(DLL) change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp; : COND_ALIASING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Alias
change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4&nbsp;&nbsp; : COND_THREAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- Thread change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5&nbsp;&nbsp; : COND_THREAD_EXTRA&nbsp;&nbsp;&nbsp;&nbsp; - Thread extra change</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6&nbsp;&nbsp; : COND_TRACE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Trace point occurred</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 7&nbsp;&nbsp; : COND_BREAK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Break point occurred</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 8&nbsp;&nbsp; : COND_WATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Watch point occurred</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 9&nbsp;&nbsp; : COND_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - User interrupt</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 10&nbsp; : COND_TERMINATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program terminated</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 11&nbsp; : COND_EXCEPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Machine exception</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 12&nbsp; : COND_MESSAGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Message
to be displayed</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 13&nbsp; : COND_STOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;- Debuggee wants to stop</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 14&nbsp; : not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 15&nbsp; : not used</tt>
<br><br>When a bit is off, the debugger avoids having to make additional requests to determine the new state of the debuggee.
&nbsp;If the trap file is not sure that a particular item has changed, or if it is expensive to find out, it should just turn
the bit on.
<h3 id="REQ_PROG_LOAD_L20R"> REQ_PROG_LOAD (20) </h3>
<br>Request to load a program.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true_argv</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argv</tt>
<br><br>The<tt> true_argv</tt> field indicates whether the argument consists of a single string, or a true C-style argument
vector.&nbsp; This field is set to be one for a true argument vector and zero otherwise.&nbsp; The<tt> argv</tt> is a set
of zero-terminated strings, one following each other.&nbsp; The first string gives the name of the program to be loaded.&nbsp;
The remainder of the<tt> argv</tt> field contains the program's arguments.&nbsp; The arguments can be a single string or an
array of strings.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_phandle&nbsp;&nbsp;&nbsp; task_id</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; mod_handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</tt>
<br><br>The<tt> err</tt> field returns the error code while loading the program.&nbsp; The<tt> task_id</tt> shows the task
(process) ID for the program loaded.&nbsp; The<tt> mod_handle</tt> is the system module identification for the executable
image.&nbsp; It is used as input to the REQ_MAP_ADDR request.&nbsp; The<tt> flags</tt> field contains the following information:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0 :&nbsp; LD_FLAG_IS_32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; - 32-bit program (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1 :&nbsp; LD_FLAG_IS_PROT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- Protected mode (obsolete)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2 :&nbsp; LD_FLAG_IS_STARTED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Program already
started</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3 :&nbsp; LD_FLAG_IGNORE_SEGMENTS&nbsp;&nbsp; - Ignore segments (flat)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4 :&nbsp; LD_FLAG_HAVE_RUNTIME_DLLS - DLL load breaks supported</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 5 :&nbsp; LD_FLAG_DISPLAY_DAMAGED&nbsp;&nbsp; - Debugger must repaint screen</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 6 :&nbsp; not used</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 7 :&nbsp; not used</tt>
<h3 id="REQ_PROG_KILL_L21R"> REQ_PROG_KILL (21) </h3>
<br>Request to kill the program.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_phandle&nbsp;&nbsp;&nbsp; task_id</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> task_id</tt> field (obtained from REQ_PROG_LOAD) identifies
the program to be killed.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>The<tt> err</tt> field returns the error code of the OS kill program operation.
<h3 id="REQ_SET_WATCH_L22R"> REQ_SET_WATCH (22) </h3>
<br>Request to set a watchpoint at the address given.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; watch_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The address of the watchpoint is given by the<tt> watch_addr</tt> field.&nbsp; The<tt> size</tt> field gives the number
of bytes to be watched.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; multiplier</tt>
<br><br>The<tt> err</tt> field returns the error code if the setting failed.&nbsp; If the setting of the watchpoint worked,
the 31 low order bits of<tt> multiplier</tt> indicate the expected slow down of the program when it's placed into execution.
&nbsp;The top bit of the field is set to one if a debug register is being used for the watchpoint, and zero if the watchpoint
is being done by software.
<h3 id="REQ_CLEAR_WATCH_L23R"> REQ_CLEAR_WATCH (23) </h3>
<br>Request to clear a watchpoint at the address given.&nbsp; The trap file may assume all watch points are cleared at once.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; watch_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The address of the watch point is given by the<tt> watch_addr</tt> field.&nbsp; The<tt> size</tt> field gives the
size of the watch point.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_SET_BREAK_L24R"> REQ_SET_BREAK (24) </h3>
<br>Request to set a breakpoint at the address given.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_addr</tt>
<br><br>The address of the break point is given by the<tt> break_addr</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; old</tt>
<br><br>The<tt> old</tt> field returns the original byte(s) at the address<tt> break_addr</tt>.
<h3 id="REQ_CLEAR_BREAK_L25R"> REQ_CLEAR_BREAK (25) </h3>
<br>Request to clear a breakpoint at the address given.&nbsp; The trap file may assume all breakpoints are cleared at once.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_addr</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; old</tt>
<br><br>The address of the break point is given by the<tt> break_addr</tt> field.&nbsp; The<tt> old</tt> field holds the old
instruction returned from the REQ_SET_BREAK request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_GET_NEXT_ALIAS_L26R"> REQ_GET_NEXT_ALIAS (26) </h3>
<br>Request to get alias information for a segment.&nbsp; In some protect mode environments (typically 32-bit flat) two different
selectors may refer to the same physical memory.&nbsp; Which selectors do this is important to the debugger in certain cases
(so that symbolic information is properly displayed).
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; seg</tt>
<br><br>The<tt> seg</tt> field contains the segment.&nbsp; To get the first alias, put zero in this field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; seg</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; alias</tt>
<br><br>The<tt> seg</tt> field contains the next segment where an alias appears.&nbsp; If this field returns zero, it implies
no more aliases can be found.&nbsp; The<tt> alias</tt> field returns the alias of the input segment.&nbsp; Zero indicates
a previously set alias should be deleted.
<h3 id="REQ_SET_USER_SCREEN_L27R"> REQ_SET_USER_SCREEN (27) </h3>
<br>Request to make the debuggee's screen visible.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_SET_DEBUG_SCREEN_L28R"> REQ_SET_DEBUG_SCREEN (28) </h3>
<br>Request to make the debugger's screen visible.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_READ_USER_KEYBOARD_L29R"> REQ_READ_USER_KEYBOARD (29) </h3>
<br>Request to read the remote keyboard input.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; wait</tt>
<br><br>The request will be time out if it waits longer than the period specifies in the<tt> wait</tt> field.&nbsp; The waiting
period is measured in seconds.&nbsp; A value of zero means to wait forever.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key</tt>
<br><br>The<tt> key</tt> field returns the input character from remote machine.
<h3 id="REQ_GET_LIB_NAME_L30R"> REQ_GET_LIB_NAME (30) </h3>
<br>Request to get the name of a newly loaded library (DLL).
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><br>The<tt> handle</tt> field contains the library handle.&nbsp; It should be zero to get the name of the first DLL or
the value from the<tt> handle</tt> of a previous request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_mhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> handle</tt> field contains the library handle.&nbsp; It contains zero if there are no more DLL names to be
returned.&nbsp; The name of the library will be returned in<tt> name</tt> field.&nbsp; If the<tt> name</tt> field is an empty
string (consists just of the '\0' character), then this is a indication that the DLL indicated by the given handle has been
unloaded, and the debugger should remove any symbolic information for the image.&nbsp; It is an error to attempt to remove
a handle that has not been loaded in a previous REQ_GET_LIB_NAME request.
<h3 id="REQ_GET_ERR_TEXT_L31R"> REQ_GET_ERR_TEXT (31) </h3>
<br>Request to get the error message text for an error code.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>The<tt> err</tt> field contains the error code number of the error text requested.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_msg</tt>
<br><br>The error message text will be returned in<tt> error_msg</tt> field.
<h3 id="REQ_GET_MESSAGE_TEXT_L32R"> REQ_GET_MESSAGE_TEXT (32) </h3>
<br>Request to retrieve generic message text.&nbsp; After a REQ_PROG_LOAD, REQ_PROG_GO or REQ_PROG_STEP has returned with
COND_MESSAGE or COND_EXCEPTION, the debugger will make this request to obtain the message text.&nbsp; In the case of a COND_EXCEPTION
return text describing the machine exception that caused the return to the debugger.&nbsp; Otherwise return whatever generic
message text that the trap file wants to display to the user.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg</tt>
<br><br>The message text will be returned in the<tt> msg</tt> field.&nbsp; The<tt> flags</tt> contains a number of bits which
control the next action of the debugger.&nbsp; They are:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_NEWLINE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_MORE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_WARNING</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : MSG_ERROR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4 - 7&nbsp;&nbsp; : not used</tt>
<br><br>The MSG_NEWLINE bit indicates that the debugger should scroll its display to a new line after displaying the message.
&nbsp;The MSG_MORE bit indicates that there is another line of output to come and the debugger should make another REQ_GET_MESSAGE_TEXT.
&nbsp;MSG_WARNING indicates that the message is a warning level message while MSG_ERROR is an error level message.&nbsp; If
neither of these bits are on, the message is merely informational.
<h3 id="REQ_REDIRECT_STDIN_L33RDREQ_REDIRECT_STDOUT_L34R"> REQ_REDIRECT_STDIN (33)/REQ_REDIRECT_STDOUT (34) </h3>
<br>Request to redirect the standard input (REQ_REDIRECT_STDIN) or standard output (REQ_REDIRECT_STDOUT) of the debuggee.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The file name to be redirected to/from is given by the<tt> name</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>When an error has occurred, the<tt> err</tt> field contains an error code indicating the type of error that has been
detected.
<br><br><b>NOTE:</b>&nbsp; and almost all of them also do not return an accurate error code for failures.&nbsp; This is work
in progress.&nbsp; The debugger may report an error to open the specified file rather than report that the requested operation
is not supported.
<h3 id="REQ_SPLIT_CMD_L35R"> REQ_SPLIT_CMD (35) </h3>
<br>Request to split the command line into the command name and parameters.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd</tt>
<br><br>The<tt> cmd</tt> field contains the command.&nbsp; Command can be a single command line or an array of command strings.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; cmd_end</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; parm_start</tt>
<br><br>The<tt> cmd_end</tt> field tells the position in command line where the command name ends.&nbsp; The<tt> parm_start</tt>
field stores the position where the program arguments begin.
<h3 id="REQ_READ_REGS_L36R"> REQ_READ_REGS (36) </h3>
<br>Request to read CPU register contents.&nbsp; The data returned depends on the target architecture and is defined by the
MAD file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The return message content is specific to the MAD in use and will contain a<tt> mad_registers</tt> union (defined
in<tt> madtypes.h</tt>).
<h3 id="REQ_WRITE_REGS_L37R"> REQ_WRITE_REGS (37) </h3>
<br>Request to write CPU register contents.&nbsp; The data is target architecture specific.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The message content is specific to the MAD in use and will contain a<tt> mad_registers</tt> union.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_MACHINE_DATA_L38R"> REQ_MACHINE_DATA (38) </h3>
<br>Request to retrieve machine specific data.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info_type;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The<tt> info_type</tt> field specifies what kind of information should be returned and<tt> addr</tt> determines the
address for which the information is requested.&nbsp; The remainder of the message is MAD specific.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache_start;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; addr48_off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cache_end;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unspecified</tt>
<br><br>The return message content is specific to the MAD in use.
<h2 id="File_IDO_requests"> File I/O requests </h2>
<br>This section describes requests that deal with file input/output on the target (debuggee) machine.&nbsp; These requests
are actually performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following
descriptions do not show that &quot;prefix&quot; to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Files&quot;.
<br><br>The file requests use a new basic type in addition to the ones already described:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>trap_fhandle
<dd>This is an<tt> unsigned_32</tt> which holds a debuggee file handle.
</dl>
<h3 id="REQ_FILE_GET_CONFIG_L0R"> REQ_FILE_GET_CONFIG (0) </h3>
<br>Request to retreive characteristics of the remote file system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ext_separator;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_separator&#91;3&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newline&#91;2&#93;;</tt>
<br><br>The<tt> ext_separator</tt> contains the separator for file name extensions.&nbsp; The possible path separators can
be found in array<tt> path_separator</tt>.&nbsp; The first one is the &quot;preferred&quot; path separator for that operating
system.&nbsp; This is the path separator that the debugger will use if it needs to construct a file name for the remote system.
&nbsp;The new line control characters are stored in array<tt> newline</tt>.&nbsp; If the operating system uses only a single
character for newline, put a zero in the second element.
<h3 id="REQ_FILE_OPEN_L1R"> REQ_FILE_OPEN (1) </h3>
<br>Request to create/open a file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The name of the file to be opened is given by<tt> name</tt>.&nbsp; The<tt> mode</tt> field stores the access mode
of the file.&nbsp; The following bits are defined:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_READ</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_WRITE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_CREATE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp; TF_EXEC</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bit 4 - 7&nbsp; :&nbsp; not used</tt>
<br><br>For read/write mode, turn both<tt> TF_READ</tt> and<tt> TF_WRITE</tt> bits on.&nbsp; The<tt> TF_EXEC</tt> bit should
only be used together with<tt> TF_CREATE</tt> and indicates that the created file needs executable permission (if relevant
on the target platform).
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><br>If successful, the<tt> handle</tt> returns a handle for the file.&nbsp; When an error has occurred, the<tt> err</tt>
field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_SEEK_L2R"> REQ_FILE_SEEK (2) </h3>
<br>Request to seek to a particular file position.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; pos</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.&nbsp; The<tt> mode</tt> field stores the seek mode.
&nbsp;There are three seek modes:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_ORG = 0&nbsp; - Relative to the start of file</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_CUR = 1&nbsp; - Relative to the current file position</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_SEEK_END = 2&nbsp; - Rrelative to the end of file</tt>
<br><br>The position to seek to is in the<tt> pos</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; pos</tt>
<br><br>If an error has occurred, the<tt> err</tt> field contains a value indicating the type of error that has been detected.
&nbsp;The<tt> pos</tt> field returns the current position of the file.
<h3 id="REQ_FILE_READ_L3R"> REQ_FILE_READ (3) </h3>
<br>Request to read a block of data from a file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.&nbsp; The<tt> len</tt> field stores the number of bytes
to be transmitted.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
data</tt>
<br><br>If successful, the<tt> data</tt> returns the block of data.&nbsp; The length of returned data is given by the return
value of TrapRequest minus 4 (to account for the size of<tt> err</tt>).&nbsp; The length will normally be equal to the<tt>
len</tt> field.&nbsp; If the end of file is encountered before the read completes, the return value will be less than the
number of bytes requested.&nbsp; When an error has occurred, the<tt> err</tt> field contains a value indicating the type of
error that has been detected.
<h3 id="REQ_FILE_WRITE_L4R"> REQ_FILE_WRITE (4) </h3>
<br>Request to write a block of data to a file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.&nbsp; The data is given in<tt> data</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>If there is no error,<tt> len</tt> will equal to that in the<tt> data_len</tt> field.&nbsp; When an error has occurred,
the<tt> err</tt> field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_WRITE_CONSOLE_L5R"> REQ_FILE_WRITE_CONSOLE (5) </h3>
<br>Request to write a block of data to the debuggee's screen.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The data is given in<tt> data</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; len</tt>
<br><br>If there is no error,<tt> len</tt> will equal to the<tt> data_len</tt> field.&nbsp; When an error has occurred, the<tt>
err</tt> field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_CLOSE_L6R"> REQ_FILE_CLOSE (6) </h3>
<br>Request to close a file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><br>The handle of the file is given by the<tt> handle</tt> field.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>When an error has occurred, the<tt> err</tt> field contains a value indicating the type of error that has been detected.
<h3 id="REQ_FILE_ERASE_L7R"> REQ_FILE_ERASE (7) </h3>
<br>Request to erase a file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</tt>
<br><br>The<tt> file_name</tt> field contains the file name to be deleted.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp; err</tt>
<br><br>If error has occurred when erasing the file, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_FILE_STRING_TO_FULLPATH_L8R"> REQ_FILE_STRING_TO_FULLPATH (8) </h3>
<br>Request to convert a file name to its full path name.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_type</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</tt>
<br><br>The<tt> file_type</tt> field indicates the type of the input file.&nbsp; File types can be:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_EXE&nbsp; =&nbsp; 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_DBG&nbsp; =&nbsp; 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_PRS&nbsp; =&nbsp; 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TF_FILE_HLP&nbsp; =&nbsp; 3</tt>
<br><br>This is so the trap file can search different paths for the different types of files.&nbsp; For example, under QNX,
the PATH environment variable is searched for the FILE_EXE type, and the WD_PATH environment variable is searched for the
others.&nbsp; The<tt> file_name</tt> field contains the file name to be converted.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_name</tt>
<br><br>If no error occurs the<tt> err</tt> field returns a zero and the full path name will be stored in the<tt> path_name</tt>
field.&nbsp; When an error has occurred, the<tt> err</tt> field contains an error code indicating the type of error that has
been detected.
<h3 id="REQ_FILE_RUN_CMD_L9R"> REQ_FILE_RUN_CMD (9) </h3>
<br>Request to run a command on the target (debuggee's) system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; chk_size</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd</tt>
<br><br>The<tt> chk_size</tt> field gives the check size in kilobytes.&nbsp; This field is only useful in the DOS implementation.
&nbsp;It contains the value of the /CHECKSIZE debugger command line option and represents the amount of memory the user wishes
to have free for the spawned sub-shell.&nbsp; The<tt> cmd</tt> field stores the command to be executed.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred when executing the command, the<tt> err</tt> field will return the error code number.
<h2 id="Overlay_requests"> Overlay requests </h2>
<br>This section describes requests that deal with overlays (supported only under 16-bit DOS).&nbsp; These requests are actually
performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions
do not show that &quot;prefix&quot; to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Overlays&quot;.
<br><br>The overlay requests use a new basic type in addition to the ones already described:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>addr32_ptr
<dd>This type encapsulates the concept of a 16:16 pointer into the debuggee's address space.&nbsp; Since overlays are only useful
for 16-bit environments, using the addr48_ptr type would be inefficient.&nbsp; The structure is defined as follows:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp; segment;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } addr32_ptr;</tt>
<br><br>The<tt> segment</tt> field contains the segment of the address and the<tt> offset</tt> field stores the offset of
the address.
<dt><br>ovl_address
<dd>This type contains the overlay address and the number of entries down in the overlay stack.&nbsp; The structure is defined
as follows:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr32_ptr&nbsp; mach;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16 sect_id;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } ovl_address;</tt>
<br><br>The<tt> mach</tt> field is the machine address.&nbsp; The<tt> sect_id</tt> field stores the address section number.
</dl>
<h3 id="REQ_OVL_STATE_SIZE_L0R"> REQ_OVL_STATE_SIZE (0) </h3>
<br>Request to return the size of the overlay state information in bytes of the task program.&nbsp; This request maps onto
the overlay manager's GET_STATE_SIZE request.&nbsp; See the Overlay Manager Interface document for more information on the
contents of the return message.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The<tt> size</tt> field returns the size in bytes.&nbsp; A value of zero indicates no overlays are present in the
debuggee and none of the other requests dealing with overlays will ever be called.
<h3 id="REQ_OVL_GET_DATA_L1R"> REQ_OVL_GET_DATA (1) </h3>
<br>Request to get the address and size of an overlay section.&nbsp; This request maps onto the overlay manager's GET_SECTION_DATA
request.&nbsp; See the Overlay Manager Interface document for more information on the contents of the return message.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; sect_id</tt>
<br><br>The<tt> sect_id</tt> field indicates the overlay section the information is being requested of.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; segment</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The<tt> segment</tt> field contains the segment value where the overlay section is loaded (or would be loaded if it
was brought into memory).&nbsp; The<tt> size</tt> field gives the size, in bytes, of the overlay section.&nbsp; If there is
no section for the given id, the<tt> segment</tt> field will be zero.
<h3 id="REQ_OVL_READ_STATE_L2R"> REQ_OVL_READ_STATE (2) </h3>
<br>Request to read the overlay table state.&nbsp; This request maps onto the overlay manager's GET_OVERLAY_STATE request.
&nbsp;See the Overlay Manager Interface document for more information on the contents of the return message.&nbsp; The size
of the returned data is provided by the REQ_OVL_STATE_SIZE trap file request.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field contains the overlay state information requested.
<h3 id="REQ_OVL_WRITE_STATE_L3R"> REQ_OVL_WRITE_STATE (3) </h3>
<br>Request to write the overlay table state.&nbsp; This request maps onto the overlay manager's SET_OVERLAY_STATE request.
&nbsp;See the Overlay Manager Interface document for more information on the contents of the return message.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data</tt>
<br><br>The<tt> data</tt> field contains the overlay state information to be restored.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_OVL_TRANS_VECT_ADDR_L4R"> REQ_OVL_TRANS_VECT_ADDR (4) </h3>
<br>Request to check if the input overlay address is actually an overlay vector.&nbsp; This request maps onto the overlay
manager's TRANSLATE_VECTOR_ADDR request.&nbsp; See the Overlay Manager Interface document for more information on the contents
of the messages.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The<tt> mach</tt> field is the machine address.&nbsp; The<tt> sect_id</tt> field stores the number of entries down
in the overlay stack.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The translated address will be returned in the<tt> ovl_addr</tt> field.&nbsp; If the address is not an overlay vector,
then the input address will be returned and the<tt> sect_id</tt> field will be zero.
<h3 id="REQ_OVL_TRANS_RET_ADDR_L5R"> REQ_OVL_TRANS_RET_ADDR (5) </h3>
<br>Request to check if the address is the overlay manager parallel return code.&nbsp; This request maps onto the overlay
manager's TRANSLATE_RETURN_ADDR request.&nbsp; See the Overlay Manager Interface document for more information on the contents
of the messages.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The translated address will be returned in the<tt> ovl_addr</tt> field.&nbsp; If the address is not an parallel return
code, then the input address will be returned and the<tt> sect_id</tt> field in the structure<tt> ovl_addr</tt> will be zero.
<h3 id="REQ_OVL_GET_REMAP_ENTRY_L6R"> REQ_OVL_GET_REMAP_ENTRY (6) </h3>
<br>Request to check if the overlay address needs to be remapped.&nbsp; This request maps onto the overlay manager's GET_MOVED_SECTION
request.&nbsp; See the Overlay Manager Interface document for more information on the contents of the messages.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>The<tt> ovl_addr</tt> field contains the overlay address.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remapped</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ovl_address&nbsp;&nbsp;&nbsp;&nbsp; ovl_addr</tt>
<br><br>If the address gets remapped the<tt> remapped</tt> field will return one.&nbsp; The remapped address will be returned
in the<tt> ovl_addr</tt> field.&nbsp; The input address will be unchanged if the address has not been remapped.
<h2 id="Thread_requests"> Thread requests </h2>
<br>This section descibes requests that deal with threads.&nbsp; These requests are actually performed by the core request
REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions do not show that &quot;prefix&quot;
to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;Threads&quot;.
<br><br>The thread requests use a new basic type in addition to the ones already described:
<dl>
<dt><b><i>Type</i></b>
<dd><b><i>Definition</i></b>
<dt><br>trap_thandle
<dd>This is an<tt> unsigned_32</tt> which holds a thread handle.
</dl>
<h3 id="REQ_THREAD_GET_NEXT_L0R"> REQ_THREAD_GET_NEXT (0) </h3>
<br>Request to get next thread.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the either a zero to get information on the first thread, or the value of the<tt> thread</tt>
field in the return message of a previous request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state</tt>
<br><br>The<tt> thread</tt> field returns the thread ID.&nbsp; There are no more threads in the list, it will contain zero.
&nbsp;The<tt> state</tt> field can have two values:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; THREAD_THAWED = 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; THREAD_FROZEN = 1</tt>
<h3 id="REQ_THREAD_SET_L1R"> REQ_THREAD_SET (1) </h3>
<br>Request to set a given thread ID to be the current thread.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the thread number to set.&nbsp; If it's zero, do not attempt to set the thread, just
return the current thread ID.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; old_thread</tt>
<br><br>The<tt> old_thread</tt> field returns the previous thread ID.&nbsp; If the set fails, the<tt> err</tt> field will
be non-zero.
<h3 id="REQ_THREAD_FREEZE_L2R"> REQ_THREAD_FREEZE (2) </h3>
<br>Request to freeze a thread so that it will not be run next time when executing the task program.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the thread number to freeze.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If the thread cannot be frozen, the<tt> err</tt> field returns non-zero value.
<h3 id="REQ_THREAD_THAW_L3R"> REQ_THREAD_THAW (3) </h3>
<br>Request to allow a thread to run next time when executing the program.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_thandle&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> contains the thread number to thaw.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If the thread cannot be thawed, the<tt> err</tt> field returns non zero value.
<h3 id="REQ_THREAD_GET_EXTRA_L4R"> REQ_THREAD_GET_EXTRA (4) </h3>
<br>Request to get extra information about a thread.&nbsp; This is arbitrary textual data which the debugger merely displays
in its thread window.&nbsp; The trap file can place any information in the return message which it feels would be useful for
the user to know.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; thread</tt>
<br><br>The<tt> thread</tt> field contains the thread ID.&nbsp; A zero value means to get the title string for the thread
extra information.&nbsp; This is displayed at the top of the thread window.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extra</tt>
<br><br>The extra information of the thread will be returned in<tt> extra</tt> field.
<h2 id="RFX_requests"> RFX requests </h2>
<br>This section deals with requests that are only used by the RFX (Remote File Xfer) program.&nbsp; These requests are actually
performed by the core request REQ_PERFORM_SUPPLEMENTARY_SERVICE and appropriate service ID.&nbsp; The following descriptions
do not show that &quot;prefix&quot; to the request messages.
<br><br>The service name to be used in the REQ_GET_SUPPLEMENTARY_SERVICE is &quot;RFX&quot;.
<h3 id="REQ_RFX_RENAME_L0R"> REQ_RFX_RENAME (0) </h3>
<br>Request to rename a file on the debuggee's system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from_name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to_name</tt>
<br><br>The file whose name is indicated by the field<tt> from_name</tt> will be renamed to the name given by the field<tt>
to_name</tt>
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_MKDIR_L1R"> REQ_RFX_MKDIR (1) </h3>
<br>Request to create a directory on the target (debuggee) system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be created.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred when creating the directory, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_RMDIR_L2R"> REQ_RFX_RMDIR (2) </h3>
<br>Request to remove a directory on the target system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be removed.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_SETDRIVE_L3R"> REQ_RFX_SETDRIVE (3) </h3>
<br>Request to set the current drive on the target system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field contains the drive number to be set on the target system.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_GETDRIVE_L4R"> REQ_RFX_GETDRIVE (4) </h3>
<br>Request to get the current drive on the target system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field returns the current drive number on the target system.
<h3 id="REQ_RFX_SETCWD_L5R"> REQ_RFX_SETCWD (5) </h3>
<br>Request to set a directory on the target system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be set.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_GETCWD_L6R"> REQ_RFX_GETCWD (6) </h3>
<br>Request to get the current directory name on the target system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field contains the target drive number.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dir_name</tt>
<br><br>The<tt> dir_name</tt> field contains the name of the directory to be set.&nbsp; If error has occurred, the<tt> err</tt>
field will return the error code number.
<h3 id="REQ_RFX_SETDATETIME_L7R"> REQ_RFX_SETDATETIME (7) </h3>
<br>Request to set a file's date and time information on the target system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time</tt>
<br><br>The<tt> handle</tt> contains the file handle.&nbsp; The<tt> time</tt> field follows the UNIX time format.&nbsp; The<tt>
time</tt> represents the time since January 1, 1970 (UTC).
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; NONE</tt>
<h3 id="REQ_RFX_GETDATETIME_L8R"> REQ_RFX_GETDATETIME (8) </h3>
<br>Request to get the date and time information for a file on the target system.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_fhandle&nbsp;&nbsp;&nbsp; handle</tt>
<br><br>The<tt> handle</tt> contains the file handle.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time</tt>
<br><br>The<tt> time</tt> field follows the UNIX time format.&nbsp; The<tt> time</tt> represents the time since January 1,
1970 (UTC).
<h3 id="REQ_RFX_GETFREESPACE_L9R"> REQ_RFX_GETFREESPACE (9) </h3>
<br>Request to get the amount of free space left on the drive.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drive</tt>
<br><br>The<tt> drive</tt> field contains the target drive number.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; size</tt>
<br><br>The<tt> size</tt> field returns the number of bytes left on the drive.
<h3 id="REQ_RFX_SETFILEATTR_L10R"> REQ_RFX_SETFILEATTR (10) </h3>
<br>Request to set the file attribute of a file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; attribute</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> name</tt> field contains the name whose attributes are to be set.&nbsp; The<tt> attribute</tt> field contains
the new attributes of the file.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If error has occurred, the<tt> err</tt> field will return the error code number.
<h3 id="REQ_RFX_GETFILEATTR_L11R"> REQ_RFX_GETFILEATTR (11) </h3>
<br>Request to get the file attribute of a file.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> name</tt> field contains the name to be checked.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp; attribute</tt>
<br><br>The<tt> attribute</tt> field returns the attribute of the file.
<h3 id="REQ_RFX_NAMETOCANNONICAL_L12R"> REQ_RFX_NAMETOCANNONICAL (12) </h3>
<br>Request to convert a file name to its canonical form.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name</tt>
<br><br>The<tt> file_name</tt> field contains the file name to be converted.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path_name</tt>
<br><br>If there is no error, the<tt> err</tt> field returns a zero and the full path name will be stored in the<tt> path_name</tt>
field.&nbsp; When an error has occurred, the<tt> err</tt> field contains an error code indicating the type of error that has
been detected.
<h3 id="REQ_RFX_FINDFIRST_L13R"> REQ_RFX_FINDFIRST (13) </h3>
<br>Request to find the first file in a directory.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrib</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ----------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name</tt>
<br><br>The<tt> name</tt> field contains the name of the directory and the<tt> attrib</tt> field contains the attribute of
the files to list in the directory.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; dta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</tt>
<br><br>If found, the<tt> err</tt> field will be zero.&nbsp; The location and information of about the first file will be
in the structure<tt> info.</tt>&nbsp; Definition of the structure<tt> dta</tt> is as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct dta {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; spare1&#91;13&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; dir_entry_num;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; cluster;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; spare2&#91;4&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } dos;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
attr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
name&#91;14&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } dta;</tt>
<h3 id="REQ_RFX_FINDNEXT_L14R"> REQ_RFX_FINDNEXT (14) </h3>
<br>Request to find the next file in the directory.&nbsp; This request should be used only after REQ_RFX_FINDFIRST.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; --------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; dta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</tt>
<br><br>The<tt> req</tt> field contains the request.&nbsp; The<tt> info</tt> field contains the dta returned from the previous
REQ_FIND_NEXT or REQ_FIND_FIRST.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -----------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; dta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info</tt>
<br><br>The<tt> info</tt> field is the same as in REQ_FIND_FIRST.
<h3 id="REQ_RFX_FINDCLOSE_L15R"> REQ_RFX_FINDCLOSE (15) </h3>
<br>Request to end the directory search operation.
<br><br><tt>Request message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; access_req&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req</tt>
<br><br>The<tt> req</tt> field contains the request.
<br><br><tt>Return message:</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; trap_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err</tt>
<br><br>If successful, the<tt> err</tt> field will be zero, otherwise the system error code will be returned.
<h1 id="System_Dependent_Aspects"> System Dependent Aspects </h1>
<br>Every environment has a different method of loading the code for the trap file and locating the TrapInit, TrapRequest,
and TrapFini routines.&nbsp; This section descibes how the Open Watcom debugger performs these operations for the various
systems.
<h2 id="Trap_Files_Under_DOS"> Trap Files Under DOS </h2>
<br>A trap file is an &quot;EXE&quot; format file with the extension &quot;.TRP&quot;.&nbsp; The debugger searches the directories
specified by the PATH environment variable.&nbsp; Once found, it is loaded into memory and has the normal EXE style relocations
applied to the image.&nbsp; Then the lowest address in the load image (NOTE:&nbsp; not the starting address from EXE header
information) is examined for the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; signature; /* == 0xDEAF */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; init_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; acc_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; fini_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } trap_header;</tt>
<br><br>If the first 2 bytes contain the value 0xDEAF, the file is considered to be a valid trap file and the<tt> init_off</tt>,<tt>
acc_off</tt>, and<tt> fini_off</tt> fields are used to obtain the offsets of the TrapInit, TrapRequest, and TrapFini routines
repectively.
<br><br>The starting address field of the EXE header should be set to point at some code which prints out a message about
not being able to be run from the command line and then terminates.
<h2 id="Trap_Files_Under_OSD2"> Trap Files Under OS/2 </h2>
<br>A trap file is a normal OS/2 DLL.&nbsp; The system automatically searches the directories specified by the LIBPATH command
in the CONFIG.SYS file.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 1 from the DLL for TrapInit, export
ordinal 2 for TrapFini and export ordinal 3 for TrapRequest.&nbsp; Some example code follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; rc = DosLoadModule( NULL, 0, trap_file_name, &amp;dll_module );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( DosGetProcAddr( dll_module, &quot;#1&quot;, &amp;TrapInit ) != 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || DosGetProcAddr( dll_module, &quot;#2&quot;, &amp;TrapFini ) != 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || DosGetProcAddr( dll_module, &quot;#3&quot;, &amp;TrapRequest ) != 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<h2 id="Trap_Files_Under_Windows_"> Trap Files Under Windows. </h2>
<br>A trap file is a normal Windows DLL.&nbsp; The system automatically searches the directories specified by the PATH environment
variable.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 2 from the DLL for TrapInit, export ordinal 3 for
TrapFini and export ordinal 4 for TrapRequest.&nbsp; Some example code follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; dll = LoadLibrary( trap_file_name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( dll &lt; 32 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapInit&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapFini&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapRequest = (LPVOID) GetProcAddress( dll, (LPSTR)4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( TrapInit == NULL || TrapFini == NULL || TrapRequest == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<h2 id="Trap_Files_Under_Windows_NT_"> Trap Files Under Windows NT. </h2>
<br>A trap file is a normal Windows NT DLL.&nbsp; The system automatically searches the directories specified by the PATH
environment variable.&nbsp; Once loaded, the Open Watcom debugger uses export ordinal 1 from the DLL for TrapInit, export
ordinal 2 for TrapFini and export ordinal 3 for TrapRequest.&nbsp; Some example code follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; dll = LoadLibrary( trap_file_name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( dll &lt; 32 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;unable to load trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapInit&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapFini&nbsp;&nbsp; = (LPVOID) GetProcAddress( dll, (LPSTR)2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; TrapRequest = (LPVOID) GetProcAddress( dll, (LPSTR)3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( TrapInit == NULL || TrapFini == NULL || TrapRequest == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( &quot;incorrect version of trap file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<h2 id="Trap_Files_Under_QNX"> Trap Files Under QNX </h2>
<br>A trap file is a QNX load module format file with the extension &quot;.trp&quot; and whose file permissions are not marked
as executable.&nbsp; The debugger searches the directories specified by the WD_PATH environment variable and then the &quot;/usr/watcom/wd&quot;
directory.&nbsp; Once found, it is loaded into memory and has the normal loader relocations applied to the image.&nbsp; Then
the lowest address in the load image (NOTE:&nbsp; not the starting address from load module header information) is examined
for the following structure:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; signature; /* == 0xDEAF */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; init_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; acc_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_16&nbsp;&nbsp;&nbsp;&nbsp; fini_off;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; } trap_header;</tt>
<br><br>If the first 2 bytes contain the value 0xDEAF, the file is considered to be a valid trap file and the<tt> init_off</tt>,<tt>
acc_off</tt>, and<tt> fini_off</tt> fields are used to obtain the offsets of the TrapInit, TrapRequest, and TrapFini routines
repectively.
<br><br>The starting address field of the load image header should be set to point at some code which prints out a message
about not being able to be run from the command line and then terminates.
<h2 id="Trap_Files_Under_Netware_386"> Trap Files Under Netware 386 </h2>
<br>The trap file routines are linked directly into the remote server code and TrapInit, TrapRequest, TrapFini are directly
called.
</body>
